ROOFLYTICS – SYSTEM ARCHITECTURE & IMPLEMENTATION (v1.0)
=======================================================

GOAL
Design a clean, scalable, API-first geospatial AI system where ALL machine
learning, geospatial processing, and analytics logic resides in the backend.
The frontend is strictly responsible for visualization and API interaction.

--------------------------------------------------
CORE ARCHITECTURAL PRINCIPLE
--------------------------------------------------
Frontend must contain ZERO machine learning logic.
All ML, geospatial processing, and analytics are backend responsibilities.

--------------------------------------------------
HIGH-LEVEL SYSTEM FLOW
--------------------------------------------------

Streamlit Frontend (UI only)
        ↓
FastAPI Backend (API + orchestration)
        ↓
ML & Geospatial Processing Pipeline
        ↓
Raster Outputs + Analytics
        ↓
SQLite Analytics Database (MySQL-compatible schema)

--------------------------------------------------
FRONTEND ARCHITECTURE (Streamlit)
--------------------------------------------------

Responsibilities:
• File upload (GeoTIFF)
• Trigger backend processing
• Display key metrics (roofs, energy, cost, CO₂)
• Visualize hot/cool roof overlays
• Provide download links for results

Constraints:
• No ML logic
• No geospatial processing
• API calls only

--------------------------------------------------
BACKEND ARCHITECTURE (FastAPI)
--------------------------------------------------

Responsibilities:
• Job-based processing lifecycle
• ML inference and post-processing
• Reflectance and thermal analysis
• Energy, cost, and carbon modeling
• Raster export
• Analytics persistence

Key Endpoints:
• POST /upload
• POST /process/{job_id}
• GET  /results/{job_id}
• GET  /results/{job_id}/{filename}
• GET  /health

--------------------------------------------------
BACKEND SERVICE LAYER
--------------------------------------------------

backend/services/

• data_loader.py
  - GeoTIFF loading
  - CRS and metadata preservation

• preprocessing.py
  - Normalization
  - Shadow handling
  - Tile preparation

• segmentation.py
  - U-Net inference
  - Backbone abstraction
  - Device auto-detection (CPU/GPU)

• postprocess.py
  - Mask cleanup
  - Morphological operations
  - Small object removal

• reflectance.py
  - Luminance-based reflectance computation

• clustering.py
  - Roof-level feature extraction
  - K-Means thermal clustering (hot vs cool)

• energy.py
  - Cooling-energy estimation
  - Cost and CO₂ modeling
  - Usage factor and per-roof caps

• export.py
  - GeoTIFF export utilities

• db.py
  - SQLite persistence
  - MySQL-compatible schema

--------------------------------------------------
PIPELINE EXECUTION ORDER
--------------------------------------------------

process_job(job_id):

    image, meta = load_geotiff(input.tif)

    raw_mask = segment_roofs(image)

    cleaned_mask = postprocess_mask(raw_mask)

    reflectance = compute_reflectance(image, cleaned_mask)

    roof_stats = extract_roof_reflectance(cleaned_mask, reflectance)

    roof_stats = cluster_roofs(roof_stats)

    thermal_mask = build_thermal_cluster_mask(cleaned_mask, roof_stats)

    energy_results = estimate_energy_savings(roof_stats)

    export_rasters(raw_mask, cleaned_mask, thermal_mask)

    persist_analytics_to_db(job_id, energy_results)

    return summary_metrics

--------------------------------------------------
MODEL STRATEGY
--------------------------------------------------

Two-stage model workflow:

1) DEBUG / VALIDATION MODE
   • Scratch U-Net
   • Used for verifying:
     – data loading
     – tiling
     – normalization
     – mask correctness

2) PRODUCTION MODE
   • U-Net with EfficientNet-B0 encoder
   • ImageNet pretrained
   • Faster convergence
   • Better generalization
   • Lower VRAM footprint

Backbone selection is configuration-driven and does not
affect downstream pipeline logic.

--------------------------------------------------
SEGMENTATION IMPLEMENTATION
--------------------------------------------------

Production model:
• U-Net architecture
• EfficientNet-B0 encoder
• Binary roof mask output

Design goals:
• Tile-based inference (512×512)
• Memory-aware processing
• Deterministic outputs

--------------------------------------------------
DATA PROCESSING RULES (MANDATORY)
--------------------------------------------------

NORMALIZATION
• Never rely solely on x/255 scaling
• Use:
  – ImageNet mean/std (pretrained backbones)
  – or per-image standardization

REFLECTANCE ESTIMATION
• Use luminance formulation:
  Y = 0.2126R + 0.7152G + 0.0722B
• Acts as a proxy for roof albedo

CLUSTERING
• Always standardize features before K-Means
• Prevents area or brightness dominance

--------------------------------------------------
ENERGY MODEL ARCHITECTURE
--------------------------------------------------

Energy savings are estimated at planning level:

E_saved = A × Δα × G × η × T × U

Where:
• A  = roof area (m²)
• Δα = reflectance improvement
• G  = solar irradiance
• η  = cooling efficiency
• T  = annual sunlight hours
• U  = usage factor (scene-level)

Constraints:
• Scene-level residential usage factor (default: 0.1)
• Per-roof cap: 5,000 kWh/year
• Prevents unrealistic household overestimation

--------------------------------------------------
ANALYTICS & DATABASE LAYER
--------------------------------------------------

• SQLite used for lightweight persistence
• One row per inference job
• Stores:
  – roof counts
  – energy savings
  – cost savings
  – CO₂ reduction
  – modeling assumptions
• Schema is MySQL-compatible
• Enables historical analysis and future migration

--------------------------------------------------
DEPLOYMENT ARCHITECTURE
--------------------------------------------------

v1.0 (Current)
• Streamlit frontend
• FastAPI backend
• CPU-only inference
• File-based raster outputs
• SQLite analytics persistence

v2.0 (Future)
• Improved model training
• City-scale batch processing
• External database (MySQL/Postgres)
• Map-based frontend

--------------------------------------------------
DESIGN PRINCIPLES
--------------------------------------------------
• Backend-only ML logic
• Deterministic, reproducible outputs
• Memory-aware tiled processing
• Modular service-oriented design
• Easy model swapping
• Deployment-first mindset

--------------------------------------------------
END OF DOCUMENT
--------------------------------------------------
