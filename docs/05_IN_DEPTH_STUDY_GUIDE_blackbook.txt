ROOFLYTICS – COMPLETE TECHNICAL STUDY GUIDE
(FINAL YEAR BLACK BOOK / 100 MARKS VERSION – IMPLEMENTED)
=================================================================

This document explains EVERY technical decision in depth:
• Why each component exists
• Scientific reasoning
• Mathematical foundations
• Engineering trade-offs
• Practical implementation details

GOAL:
A computer science engineering student should be able to implement the
entire Rooflytics system from scratch after studying this document.

=================================================================
TABLE OF CONTENTS
=================================================================

1. Problem Definition
2. Why Computer Vision + Semantic Segmentation
3. Dataset Characteristics (Aerial Imagery)
4. Overall System Architecture
5. Image Processing Fundamentals
6. Tiling Strategy (Memory Constraints)
7. Normalization Theory (Why NOT x/255)
8. U-Net Architecture (From Scratch)
9. Transfer Learning & EfficientNet
10. Loss Functions & Metrics
11. Mixed Precision & GPU Optimization
12. Post-processing & Morphology
13. Reflectance (Albedo) Physics
14. Luminance Formula Derivation
15. Clustering Theory (KMeans + Scaling)
16. Energy Modeling (Physics & Units)
17. Cost & Carbon Modeling
18. Geospatial Processing & GIS Outputs
19. Backend System Design
20. Deployment Decisions
21. Practical Engineering Trade-offs
22. Experimental Evaluation Strategy
23. Limitations & Assumptions
24. End-to-End Pipeline Summary

=================================================================
1. PROBLEM DEFINITION
=================================================================

Urban areas suffer from the Urban Heat Island (UHI) effect caused by
heat-absorbing materials such as dark roofs.

Chain of impact:
Dark roofs → higher solar absorption → increased indoor temperature →
higher cooling demand → increased electricity consumption →
higher carbon emissions.

GOAL:
Automatically detect rooftops from aerial imagery and estimate the
potential reduction in cooling energy if roofs are retrofitted with
high-reflectance (cool roof) materials.

INPUT:
• RGB aerial GeoTIFF imagery

OUTPUT:
• Roof segmentation mask
• Reflectance (albedo proxy)
• Hot vs cool roof classification
• Estimated cooling energy savings (kWh/year)
• Estimated cost savings
• Estimated CO₂ reduction
• GIS-compatible raster outputs

This is a combined:
• Computer vision
• Physics-informed modeling
• Geospatial analytics problem

=================================================================
2. WHY SEMANTIC SEGMENTATION?
=================================================================

Object detection produces bounding boxes, which are insufficient for:
• Precise roof area measurement
• Per-pixel reflectance estimation
• Accurate energy modeling
• GIS polygon generation

Semantic segmentation provides:
• Pixel-level roof masks
• Accurate area estimation
• Better physical modeling

Hence, a U-Net-based segmentation approach is used.

=================================================================
3. DATASET CHARACTERISTICS (AERIAL IMAGERY)
=================================================================

Challenges:
• Large image sizes (up to 10,000 × 10,000 pixels)
• Variable lighting and shadows
• Seasonal differences
• Roof material and color diversity
• Perspective distortions

Implications:
• Requires tiling
• Requires robust normalization
• Benefits from pretrained feature extractors

=================================================================
4. SYSTEM ARCHITECTURE
=================================================================

High-level architecture:

Streamlit Frontend (UI only)
        ↓
FastAPI Backend (API + orchestration)
        ↓
ML + Geospatial Processing Pipeline
        ↓
Raster Outputs + Analytics Database

Separation of concerns:
• Frontend handles interaction and visualization
• Backend handles ML, geospatial processing, and analytics

=================================================================
5. TILING STRATEGY
=================================================================

Problem:
A 10k × 10k RGB image ≈ 300 million pixels → exceeds GPU memory limits.

Solution:
• Tile image into 512 × 512 patches
• Run inference per tile
• Stitch outputs back together

Benefits:
• Constant VRAM usage
• Scalable to arbitrarily large images
• Hardware-agnostic

=================================================================
6. NORMALIZATION THEORY
=================================================================

Why x/255 scaling is insufficient:

x/255 only rescales pixel values but does not remove lighting bias.
Different tiles may have vastly different brightness distributions.

Solution:
• Per-image standardization
• OR ImageNet mean/std normalization

Mathematical form:
x_norm = (x − μ) / σ

Benefits:
• Zero-centered data
• Stable gradients
• Compatibility with pretrained backbones

This step is CRITICAL for model performance.

=================================================================
7. U-NET ARCHITECTURE (FROM SCRATCH)
=================================================================

U-Net structure:
• Encoder (context extraction)
• Decoder (spatial reconstruction)
• Skip connections (feature preservation)

Why U-Net:
• Excellent for blob-like objects (roofs)
• Preserves spatial detail
• Works well with limited data

Scratch U-Net is used ONLY for:
• Debugging
• Pipeline validation
• Sanity checks

=================================================================
8. TRANSFER LEARNING & EFFICIENTNET
=================================================================

Training from scratch:
• Requires large datasets
• Slower convergence
• Poor generalization on small data

EfficientNet advantages:
• Pretrained on ImageNet
• Strong texture and edge representations
• Efficient parameter usage (B0 variant)

Strategy:
• Scratch model → correctness
• EfficientNet-backed U-Net → production inference

=================================================================
9. LOSS FUNCTIONS
=================================================================

Binary Cross-Entropy (BCE):
• Pixel-wise classification

Dice Loss:
• Overlap-based metric
• Handles class imbalance

Final loss:
Loss = BCE + Dice

=================================================================
10. METRICS
=================================================================

Dice coefficient:
Dice = 2|A ∩ B| / (|A| + |B|)

IoU:
IoU = |A ∩ B| / |A ∪ B|

Dice is preferred for segmentation quality.

=================================================================
11. MIXED PRECISION
=================================================================

Mixed precision uses float16:
• Reduces VRAM usage
• Speeds up training

Implemented using torch.cuda.amp.

=================================================================
12. POST-PROCESSING
=================================================================

Operations:
• Morphological closing
• Small object removal
• Connected component labeling

Purpose:
• Clean roof masks
• Reduce noise
• Improve GIS compatibility

=================================================================
13. REFLECTANCE (ALBEDO) PHYSICS
=================================================================

Reflectance measures the fraction of incoming light reflected by a surface.
Higher reflectance → cooler roofs.

Direct albedo measurement is unavailable, so RGB brightness is used
as a proxy.

=================================================================
14. LUMINANCE FORMULA
=================================================================

Incorrect approach:
mean(R, G, B)

Correct luminance formulation:
Y = 0.2126R + 0.7152G + 0.0722B

This matches human-perceived brightness and physical reflectance trends.

=================================================================
15. CLUSTERING THEORY
=================================================================

Goal:
Group roofs into thermally similar classes (hot vs cool).

Method:
• Extract roof-level features
• Standardize features using StandardScaler
• Apply KMeans clustering

Scaling is mandatory to prevent feature dominance.

=================================================================
16. ENERGY MODEL PHYSICS
=================================================================

Energy saved is estimated as:

E_saved = A × Δα × G × η × T × U

Where:
• A = roof area (m²)
• Δα = reflectance improvement
• G = solar irradiance (kW/m²)
• η = cooling efficiency
• T = annual sunlight hours
• U = usage factor (scene-level)

Units:
m² × kW/m² × hours = kWh

=================================================================
17. COST & CARBON MODELING
=================================================================

Cost savings:
Cost_saved = E_saved × electricity_price

CO₂ reduction:
CO₂_saved = E_saved × emission_factor

These values represent potential planning-level estimates.

=================================================================
18. GEOSPATIAL PROCESSING
=================================================================

Raster-based processing is used to:
• Preserve spatial accuracy
• Enable GIS compatibility

Outputs:
• GeoTIFF roof masks
• GeoTIFF thermal clusters

Vector export is a future extension.

=================================================================
19. BACKEND SYSTEM DESIGN
=================================================================

FastAPI chosen for:
• High performance
• Async support
• Easy deployment

Job-based processing:
• Each request creates a job_id
• Outputs stored per job

SQLite used for analytics persistence with MySQL-compatible schema.

=================================================================
20. DEPLOYMENT DECISIONS
=================================================================

Constraints:
• Free-tier hosting
• Limited compute resources

Design choices:
• CPU-only inference support
• Tiled processing
• Lightweight models
• Minimal dependencies

=================================================================
21. PRACTICAL ENGINEERING TRADE-OFFS
=================================================================

• Accuracy vs deployability
• Physics realism vs data availability
• Model complexity vs inference cost
• Interpretability over black-box models

=================================================================
22. EXPERIMENTAL EVALUATION STRATEGY
=================================================================

Evaluation metrics:
• Dice score
• Visual inspection
• Stability across tiles

Full-scale training is planned as future work.

=================================================================
23. LIMITATIONS & ASSUMPTIONS
=================================================================

• Energy estimates are indicative, not measured
• No building-type classification
• Reflectance is a proxy
• Scene-level usage assumptions applied

=================================================================
24. END-TO-END PIPELINE SUMMARY
=================================================================

GeoTIFF
 → Tiling
 → Normalization
 → Segmentation
 → Post-processing
 → Reflectance estimation
 → Feature scaling
 → Clustering
 → Energy modeling
 → Raster export
 → Analytics persistence

=================================================================
FINAL NOTE
=================================================================

Rooflytics integrates:
• Deep Learning
• Image Processing
• Physics
• Statistics
• Geospatial Systems
• Backend Engineering

It represents a complete, real-world AI system,
not just a neural network.

-------------------------------------------------
END OF DOCUMENT
-------------------------------------------------
