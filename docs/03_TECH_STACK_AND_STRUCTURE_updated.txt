ROOFLYTICS – TECH STACK & PROJECT STRUCTURE (v1.0 – IMPLEMENTED)
===============================================================

This document defines the finalized technology stack, architectural
boundaries, and repository structure used in the Rooflytics project.

--------------------------------------------------
CORE ENGINEERING PRINCIPLES
--------------------------------------------------

1. ALL machine learning and geospatial processing runs in the backend
2. Frontend contains ZERO ML or geospatial logic
3. Tiled inference for low VRAM and large GeoTIFFs
4. Deterministic, reproducible outputs
5. Two-model development strategy:
   • Scratch U-Net → debugging & validation
   • EfficientNet-backed U-Net → production inference
6. Lightweight deployment prioritized over heavy infrastructure

--------------------------------------------------
BACKEND – MACHINE LEARNING STACK
--------------------------------------------------

Core ML
• torch
• torchvision

Segmentation Models
• segmentation_models_pytorch
• timm (required for EfficientNet encoders)

Data Processing & Utilities
• numpy
• pandas
• scipy
• scikit-learn
  – StandardScaler
  – KMeans

Image Processing
• opencv-python-headless

--------------------------------------------------
GEOSPATIAL STACK
--------------------------------------------------

Core Geospatial Libraries
• rasterio
• pyproj

(GeoPandas / Shapely intentionally avoided in v1
to reduce memory footprint and deployment complexity.)

Used for:
• GeoTIFF loading
• CRS preservation
• Raster-based spatial analysis
• GIS-ready GeoTIFF export

--------------------------------------------------
BACKEND – API & ORCHESTRATION
--------------------------------------------------

API Framework
• FastAPI
• Uvicorn

Request Handling
• python-multipart
• aiofiles
• httpx

Job Management
• Job-based processing via FastAPI routes
• Synchronous execution for MVP
• BackgroundTasks optional (future)

--------------------------------------------------
BACKEND – ANALYTICS & DATABASE
--------------------------------------------------

Persistence
• SQLite (runtime)
• File-based, lightweight, zero-configuration

Schema Design
• MySQL-compatible SQL schema
• One row per inference job
• Stores:
  – job_id
  – roof counts
  – energy savings
  – cost savings
  – CO₂ reduction
  – modeling assumptions
  – timestamps

Rationale
• Minimal resource usage
• Easy deployment
• Future migration path to MySQL/Postgres

--------------------------------------------------
FRONTEND (STREAMLIT)
--------------------------------------------------

Frontend Role
• User interaction only
• Visualization and KPI display
• No ML or geospatial processing

Libraries
• streamlit
• requests
• plotly (optional charts)
• pillow (image handling)

Features
• Upload GeoTIFF
• Trigger backend inference
• Display KPIs (energy, cost, CO₂)
• Visualize hot/cool roof overlays
• Download GeoTIFF outputs

--------------------------------------------------
MANDATORY PROCESSING RULES
--------------------------------------------------

NORMALIZATION
• DO NOT rely solely on x/255 scaling
• Use:
  – ImageNet mean/std (pretrained backbones)
  – or per-image standardization

REFLECTANCE ESTIMATION
• Use luminance-based formulation:
    Y = 0.2126R + 0.7152G + 0.0722B
• Acts as proxy for roof albedo

CLUSTERING
• Always apply StandardScaler before K-Means
• Prevents brightness or area dominance

ENERGY MODEL
• Planning-level estimation only
• Scene-level residential usage factor (default: 0.1)
• Per-roof cap: 5,000 kWh/year
• Prevents unrealistic household overestimation

--------------------------------------------------
FINAL PROJECT STRUCTURE
--------------------------------------------------

rooflytics-ai/
│
├── backend/
│   ├── app/
│   │   ├── main.py
│   │   └── routes/
│   │       ├── health.py
│   │       ├── upload.py
│   │       ├── process.py
│   │       └── results.py
│   │
│   ├── services/
│   │   ├── data_loader.py
│   │   ├── preprocessing.py
│   │   ├── segmentation.py
│   │   ├── postprocess.py
│   │   ├── reflectance.py
│   │   ├── clustering.py
│   │   ├── energy.py
│   │   ├── export.py
│   │   └── db.py
│   │
│   ├── models/
│   │   ├── unet_scratch.py
│   │   └── unet_efficientnet.py
│   │
│   └── utils/
│
├── frontend-streamlit/
│   └── app.py
│
├── training/
│   ├── train.py
│   └── train_efficientnet.py
│
├── testing/
│   └── test_segmentation.py
│
├── db/
│   ├── schema.sql
│   └── rooflytics.db
│
├── results/
│   └── <job_id>/
│
├── requirements-backend.txt
├── requirements-frontend.txt
└── README.md

--------------------------------------------------
MODEL SELECTION STRATEGY
--------------------------------------------------

Development:
• Scratch U-Net for correctness and debugging

Production:
• EfficientNet-B0 encoder
• Faster convergence
• Better generalization
• Lower memory footprint

Model choice is configuration-driven and does NOT
affect downstream pipeline logic.

--------------------------------------------------
WHY THIS STACK
--------------------------------------------------

This stack was chosen to:
• Handle very large GeoTIFFs efficiently
• Run on limited hardware and free-tier cloud platforms
• Maintain interpretability over black-box physics models
• Support future scaling without premature complexity

--------------------------------------------------
END OF DOCUMENT
--------------------------------------------------
